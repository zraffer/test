Зачем нам типы
==============

инженерия создает *сложные* (хотелось бы попроще, но приходится сложные) и *надежные* системы. 
при повышении сложности труднее добиться надежности.
проблему сложности можно победить модульностью: 
если
1. все отдельные модули надежны
2. способ их соединения надежен
то вся система тоже надежна.

для обеспечения надежности (1,2) нужны специальные усилия.

что такое *надежность* системы - определяется её спецификацией. сначала спецификация, потом реализация: нужно знать, какую систему мы разрабатываем. разработка это процесс поиска реализации по заданной спецификации. а доказательство того, что данная реализация соответствует спецификации, это *верификация*.

v-diagram

интерфейс и реализация (interface & implementation)
модули можно представлять геометрическими телами. модули соединяются своими поверхностями. для соединения модулей не нужно знать внутренность модуля. поверхность это интерфейс, внутренность это реализация. разработка снизу-вверх: если мы уверены в надежности каждого модуля по отдельности (п.1), то для сборки системы достаточно убедиться в правильности соединения модулей через интерфейсы (п.2). разработка сверху-вниз: если мы разбили требования к системе на крупные компоненты (design) и сформулировали требования к интерфейсам (п.2), то дальше можно разрабатывать компоненты по отдельности и по отдельности их верифицировать (п.1). такова инженерная победа над сложностью.

получается, что для того, чтобы надежно собирать большую программу из маленьких модуле, нужно определиться с двумя вопросами:

1. из каких частей состоит программа? что есть модуль?

	есть такой взгляд на компьютер, как на черный ящик: какая-то информация поступает в ящик (вход), каким-то образом обрабатывается в нем, и в результате обработки какая-то информация выводится наружу (выход). когда мы записываем программу, определяющую способ обработки информации внутри черного ящика, - и всю программу целиком, и отдельную ее часть, - мы должны понимать, какие данные в эту программу или ее часть поступают и какие выходят наружу.

	из такого взгляда следует, что работа программы похожа на математическое понятие функции, её запуск - на использование функции: 
	- `output = f(input)`.

	какая функция надежна? такая, которая для любого подходящего входа выдает подходящий выход. какие именно входы и выходы подходящие - определяется спецификацией.
	- `input: Input` => `output: Output`
	так рождается необходимость в понятии типа (с точки зрения спецификации). тип - это спецификация допустимых значений входных или выходных данных.

	указание типов входа и выхода - и есть декларация функции (C) или сигнатура метода (Java)

2. как соединять части программы в большую программу?

	ответ один: композиция функций 
	- `y = f(x) ; z = g(y)`
	но какая композиция надежных функций даст вновь надежную функцию, а какая - нет?
	в рамках подхода с "подходящими" входами-выходами единственым ограничением является такое: 
	- тип промежуточного значения `y`, выданный из первой функции, должен *совпадать* с типом, подходящим для второй функции. это *строгие* системы типов.
	или такое, более слабое ограничение:
    - вместо *совпадать* (про тип `y`) можно потребовать некоторую совместимость выхода первой функции с входом второй в более широком смысле, с возможностью немного изменить тип, которая все равно обеспечивает сохранение спецификации. это путь к *слабым* системам типов.

А что же такое *тип*, в том смысле, в каком он нам тут нужен? 
Это любые ограничения на обрабатываемые данные, необходимые для выражения требований в виде спецификации.
Ограничения могут касаться:
- способа реализации: как данные лежат в памяти? (нужен язык для описания данных с этой точки зрения)
- любых дополнительных условий (нужен язык логических утверждений)
Если мы отделяем первый язык (язык описания данных) от второго (языка логики), то *надежная* функция состоит из двух частей: 
- вычислительной, которая описывает преобразования данных 
- доказательной, которая представляет собой формальное рассуждение о том, что условия на выход логически следуют из условий на вход
такое разделение - это классический подход, но так делать не обязательно, можно строить язык более однородным.

------------------------

Рассуждения. Формальные рассуждения. Формальные языки (формальные системы): синтаксис и семантика. Доказательства как произвольные правильно типизированные выражения в подходящем формальном языке.

Алгебра: рассуждения об операциях и равенствах.

Функцию можно абстрактно обозначать как стрелочку `f: A -> B`. Алгебраическая структура, описывающая систему стрелочек (функций) и операцию композиции, называется категорией. Теория категорий изучает рассуждения о стрелочках внутри таких структур-категорий, (и о стрелочках между категориями и т.д...)

-------------------------

Как рассуждать о программах?
Классический подход:
Семантика - перевод программы из одного фрмального языка (языка программирования) в другой формальный язык (язык для рассуждений). 
Цели, т.е. о чем можно рассуждать:
- что программа вычислила, - в основном рассуждения, основанные на равенстве данных и равенстве самих функций, - это денотационная (сопоставляет каждому синтаксическому фрагменту математически осмысленный формальный объект)
- как программа это вычислила - рассуждения о вычислительных ресурсах, т.е. количестве и порядке вычислений, и количестве потребляемой памяти, - это операционная семантика

и отдельный подход (low hanging fruit), который появился специально для работы со спецификациями поверх императивного кода, и который сильно развит:
- аксиоматичекая семантика (предусловие - инвариант - постусловие), логика Хоара
которая превратилась в:
- контрактную парадигму, когда программирование мы начинаем с записи пред- и пост-условий 
- язык Eiffel, как основной представитель этой парадигмы
- которая долго была малопопулярна
- но которая сейчас стала известна как unit-tests & TDD (runtime tests)
- и сейчас появляются статические (compile-time) средства для того же Eiffel
- и даже к языку милитарного назначения Ada прикрутили Spark
а дальше повляются (на основе SMT Solvers):
- системы автоматического вывода доказательств Dafny 
- системы автоматической вывода программы по спецификации Suslik

-------------------------

Итак. У нас были значения и функции между ними.
После возникновения необходимости рассмотрения *спецификаций* и доказательства надежности композиции модулей-функций, у нас возникли новые слои понятий и языков для их выражения:
- уровень типов - нужны операции порождения сложных типов из простых
- уровень логики - нужны операции порождения сложных утверждений и доказательств из простых

Теперь у нас вся эта *инженерия* начинает работать не только для композции функций-над-значениями, но и для композиции функций-над-типами (generics), и функций-над-утверждениями (логический вывод, logic inference). С абстрактной точки зрения (теория типов, теория категорий) эти уровни устроены довольно похоже.

.. примеры ..

----------------------------

Какие еще бывают модули, кроме функций?

- когда мы много идентификаторов рассматриваем как принадлежащие одному целому (во время компиляции). namespace... `record` (`struct`)
- когда мы пытаемся подняться над уровнем типов: классы, интерфейсы... категории.

.. примеры ..

----------------------

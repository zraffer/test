# Зачем нам типы

## визуализация

значения и тип / values and type.
геометрическая визуализация: тело имеет внутренность и границу.

граница трехмерного - двумерна. 
граница двумерного - одномерна. 
граница одномерного - нульмерна (точки).

на границе обозначен тип.
внутренность может нести в себе любое значение данного типа.
если граница непрозрачна, то мы знаем тип, но не знаем значения.
и это хорошо, потому если мы имеем некое рассуждение о свойствах значения только через его тип, то мы получаем универсальное знание о свойствах любых значений этого типа.
это и есть ситуация статического анализа кода.

## обеспечение надежности

"Человеку свойственно ошибаться" (c) 

+ Toyota https://habr.com/company/pvs-studio/blog/310862/
+ Therac-25 https://habr.com/company/pvs-studio/blog/307788/

Ошибки при построении инженерного продукта приводят к его неправильной или ненадежной работе.
Хочется уметь создавать надежные вещи, в том числе программные продукты.

система - то, что состоит из частей.
инженерия создает *сложные* и *надежные* системы.
хотелось бы попроще, но приходится сложные. 

надежная система - та, которая всегда ведет себя правильно. 
что такое правильность поведения системы - определяется её требованиями. требования формулируется на начальном этапе разработки продукта, и могут меняться по ходу разработки. форма представления требований при этом обычно меняется в направлении конкретизации. сначала есть "хотелки" из бизнеса или маркетинга, отдельные идеи фич; постепенно они превращаются в более формальные и зафиксированные требования, учитывающие возможности реализации; конечный этап конкретизации требований мы будем называть спецификацией. спецификация должна быть сформулирована так, чтобы можно было однозначно проверить, соответствует ли ей конечный продукт. вся работа над требованиями - это инженерия требований, причем эти обязанности могут выполнять отдельные люди или они могут быть распределены в команде.

спецификация - это полная и однозначная формулировка требований к системе. сначала спецификация, потом реализация: нужно знать, какую систему мы разрабатываем. разработка это процесс поиска реализации по заданной спецификации. а доказательство того, что данная реализация соответствует спецификации, это *верификация*. верификация может происходить как путем тестирования (QA), так и формальным "математическим" анализом системы. ввиду того, что спецификация сама по себе может быть неполной или неверной, помимо верификации, необходима еще *валидация* (совпадает ли поведение с ожидаемым, неформализованным) - от простой демонстрации заказчику, и бета-тестирования в реальных условиях с реальными пользователями, до последующего сбора фидбека от пользователей службой поддержки или багрекерами.

при повышении сложности:
- есть больше мест, где можно совершить ошибку
- как следствие, труднее добиться надежности
проблему сложности можно победить *модульностью*. если:
- все отдельные модули надежны
- способ их соединения надежен
то и вся система тоже надежна.

обеспечение надежности не происходит само собой, для него нужны специальные усилия.
часть усилий может обеспечиваться специальной организацией процесса разработки, часть - специальными инструментами 
- __"процесс разработки"__ (менеджмент, формально-бюрократический способ): постоянный учет требований на всех этапах, от бизнес аналитики до отделов QA; 
- __"формальные методы"__ (computer science, формально-логический способ): от элементарной проверки типов до полного математического доказательства;

* v-diagram и её обсуждение
https://en.wikipedia.org/wiki/V-Model
https://www.google.com/search?q=vee+diagram+engineering&tbm=isch

## интерфейс и реализация / interface & implementation

модули хорошо представлять в виде геометрический тел. у тел есть внутренность и граница. модули соединяются своими границами. граница это интерфейс, внутренность это реализация. главная польза такого видения - сразу ясно, что для соединения модулей не нужно знать внутренность модуля, а только форму его границы. забегая вперед, сразу скажем, что типы - это тоже границы.

разработка снизу-вверх: если мы уверены в надежности каждого модуля по отдельности (п.1), то для сборки системы достаточно убедиться в правильности соединения модулей через интерфейсы (п.2). разработка сверху-вниз: если мы разбили требования к системе на крупные компоненты (design) и сформулировали требования к интерфейсам (п.2), то дальше можно заниматься разработкой компонентов по отдельности и по отдельности их верифицировать (п.1). 

такова инженерная победа над сложностью (а дальше начинаются подробности, как с таким подходом управляться).

наша система - программа. 
для того, чтобы надежно собирать большую программу из маленьких, нужно определиться с двумя вопросами:

1. из каких частей состоит программа? что есть модуль?
2. как соединять части программы в большую программу?

из разных ответов на эти вопросы возникают разные *парадигмы*:

- процедурная: 

1. модуль ("процедура") это отдельные действия над неким общим состоянием памяти; 
2. соединение модулей-процедур - это последовательное выполнение действий;

- функциональная (1), о ней немного подробнее:

1.	модуль
	есть такой взгляд на компьютер, как на черный ящик: какая-то информация поступает в ящик (вход), каким-то образом обрабатывается в нем, и в результате обработки какая-то информация выводится наружу (выход). когда мы записываем программу, определяющую способ обработки информации внутри черного ящика, - и всю программу целиком, и отдельную ее часть, - мы должны понимать, какие данные в эту программу или ее часть поступают и какие выходят наружу.

	из такого взгляда следует, что работа программы похожа на математическое понятие функции, её запуск - на использование функции: 
	- `output = f(input)`.

	какая функция надежна? такая, которая для любого подходящего входа выдает подходящий выход. какие именно входы и выходы подходящие - определяется спецификацией.
	- `input: Input` => `output: Output`
	так рождается необходимость в понятии типа (с точки зрения спецификации). тип - это спецификация допустимых значений входных или выходных данных.

	указание типов входа и выхода - и есть декларация функции (C) или сигнатура метода (Java)

2.	соединение модулей
	ответ один: композиция функций 
	- `y = f(x) ; z = g(y)`
	- `z = g(f(x))`
	но какая композиция надежных функций даст вновь надежную функцию, а какая - нет?
	в рамках подхода с "подходящими" входами-выходами единственым ограничением является такое: 
	- тип промежуточного значения `y`, полученный на выходе из первой функции, должен *совпадать* с типом, подходящим для входа второй функции. это *сильные* системы типов.
	или другое, более слабое ограничение:
    - вместо точного совпадения (про тип `y`) можно потребовать некоторую совместимость выхода первой функции с входом второй в более широком смысле, с возможностью немного изменить тип, которая все равно обеспечивает сохранение спецификации. например, можно разрешить незаметное преобразование булевских данных в целые числа, а их - в строки. это путь к *слабым* системам типов.

А что же такое *тип*, в том смысле, в каком он нам тут нужен? 
Это любые ограничения на обрабатываемые данные, необходимые для выражения требований в виде спецификации.
Ограничения могут касаться:
- способа реализации: как данные лежат в памяти? (нужен язык для описания данных с этой точки зрения)
- любых дополнительных условий (нужен язык логических утверждений)
Если мы отделяем первый язык (язык описания данных) от второго (языка логики), то *надежная* функция состоит из двух частей: 
- вычислительной, которая описывает преобразования данных 
- доказательной, которая представляет собой формальное рассуждение о том, что условия на выход логически следуют из условий на вход

подобное разделение - это классический подход, но так делать не обязательно, можно строить язык более однородным.

----------------------------

Какие еще бывают модули, кроме функций?

- когда мы много идентификаторов рассматриваем как принадлежащие одному целому (во время компиляции). namespace... `record` (`struct`)
- когда мы пытаемся подняться над уровнем типов: классы, интерфейсы... категории.

.. примеры ..

------------------------

Выше была упомянута логика. Что это за птица?

Рассуждения. Формальные рассуждения. Формальные языки (формальные системы): синтаксис и семантика. Доказательства как произвольные правильно типизированные выражения в подходящем формальном языке.

Алгебра: рассуждения об операциях и равенствах.

Функцию можно абстрактно обозначать как стрелочку `f: A -> B`. Алгебраическая структура, описывающая систему стрелочек (функций) и операцию композиции, называется категорией. Теория категорий изучает рассуждения о стрелочках внутри таких структур-категорий, (и еще о стрелочках между категориями и т.д...)

-------------------------

Как рассуждать о программах?
Классический подход:
Семантика - перевод программы из одного формального языка (языка программирования) в другой формальный язык (язык для рассуждений).
Объектом рассуждений и целью могут быть:
- compile-time, что программа вообще вычисляет, - в основном рассуждения, основанные на равенстве данных и равенстве самих функций, - это денотационная семантика, которая сопоставляет каждому синтаксическому фрагменту математически осмысленный формальный объект;
- run-time, каким способом программа это вычисляет - нужно, когда важны рассуждения о вычислительных ресурсах, т.е. количестве и порядке вычислений, и количестве потребляемой памяти, - это операционная семантика.

и отдельный подход (low hanging fruit), который появился специально для работы со спецификациями поверх императивного кода, и который достаточно сильно развит и используется в индустрии:
- аксиоматичекая семантика (предусловие - инвариант - постусловие), логика Хоара
которая превратилась в:
- контрактную парадигму, когда программирование мы начинаем с записи пред- и пост-условий 
- язык Eiffel, как основной представитель этой парадигмы
- которая долго была малопопулярна
- но которая сейчас стала известна как unit-tests & TDD (runtime tests)
- и сейчас появляются статические (compile-time) средства для того же Eiffel
- и даже к языку милитарного назначения Ada прикрутили Spark
- C++20: https://www.arcos.inf.uc3m.es/jdgarcia/wp-content/uploads/sites/9/2017/04/contracts.pdf
а дальше повляются (на основе SMT Solvers):
- системы автоматического вывода доказательств Dafny 
- системы автоматической вывода программы по спецификации Suslik

формальная модель против экстракции кода.

-------------------------

Итак. У нас были значения и функции между ними.
После возникновения необходимости рассмотрения *спецификаций* и доказательства надежности композиции модулей-функций, у нас возникли новые слои понятий и языков для их выражения:
- уровень типов - нужны операции порождения сложных типов из простых
- уровень логики - нужны операции порождения сложных утверждений и доказательств из простых

Теперь у нас вся эта *инженерия* начинает работать не только для композции функций-над-значениями, но и для композиции функций-над-типами (generics), и функций-над-утверждениями (логический вывод, logic inference). С абстрактной точки зрения (теория типов, теория категорий) эти уровни устроены одинаково. однако они могут отличаться представлением и временем жизни: например, статические типы существуют только в compile-time и вычисления с ними происходят в compile-time, в отличие от вычислений со значениями. и логика тоже обычно нужна только во время компиляции. стирание (erasure).

.. примеры ..

----------------------

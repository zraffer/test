# new text

## Introduction

Это будет текст о преимуществах статической типизации и о современных системах типов.
Возьмем обычную ситуацию: у нас есть переменная, ее значение и *их* тип.

```
  n := 42 : Int
```

Чей именно тип? Есть две возможности ответа на этот вопрос - считать тип либо привязанным к значению, либо привязанным к переменной. Можно изобразить это так:

```
  n := (42 : Int)
  (n : Int) := 42
```

Первый случай - это языки с динамической типизацией. Javascript, Python, Perl. Если тип привязан к значению, то, присвоив, переменной новое значение, мы окажемся в ситуации, когда переменная ссылается уже на значение другого типа, таким образом сама переменная к единственному типу не привязана.

```
  n := (42 : Int)
  n := ("ГЛАВРЫБА" : String)
```

Чтобы знать тип значения, приходится хранить его в рантайме где-то в памяти рядом с собственно значением. Чтобы корректно это значение использовать, нужно все время этот тип проверять. При этом, если мы видим использующий переменную код, но не видим код, в котором присваивается значение, то мы не может сказать заранее, на момент написания написания кода, что произойдет при использовании переменной, кроме как в виде сложного многовариантного рассуждения о том, что произойдет если тип будет `Int`, что произойдет если тип будет `String` и т.д. Отсюда постоянная неуверенность в коде, и необходимость его тестирования.

На практике, использующий код всегда предполагает определенные ограничения на тип используемой переменной, при котором он будет работоспособен. Если ожидаемый тип не совпадает с переданным, то возникнет ошибка во время выполнения. Желательно поймать все ошибки во время разработки, этим занимается этап тестирования.

Второй случай - когда тип привязан к переменной - это языки статической типизации. В них мы явно указываем типы всех переменных, и поэтому всегда знаем и то, каков тип пришедшего к нам значения, и то, какой тип должен у него быть, чтобы его использовать в нужной нам функции. Сравнение первого и второго - проверка типов, (static) type checking. Проверка типов дает гарантии еще в момент написания кода. Тестирование не нужно(!?). Некоторые языки со статической типизацией даже имеют лозунг "откомпилировалось - значит заработает!" Насколько это верно? Именно обсуждением этого мы и займемся далее.

```
  (number : Int) := 42
  (name : String) := "ГЛАВРЫБА"
```

Такие гарантии стали возможны благодаря специальному ограничению: переменная не меняет тип. Подобные ограничения позволяют упростить рассуждения о программе. Более сильным ограничением является запрет переменной менять значение, это называется иммутабельностью, оно хорошо укладывается в парадигму функционального программирования (далее).

В индустрии в настоящее время наблюдается тенденция добавлять в языки, которые традиционно были динамическими, возможность статического указания типа, причем этим занимаются крупные корпорации, лидеры рынка. [Примеры] Получается, что статическая типизация в тренде!

#### итого:

мы упомянули:
- отношение типа и значения (но что же такое тип?).
- возможность гарантировать некоторые свойства программы на момент написания кода.
- но что, собственно, мы требуем от программы? как рассуждать о выполненности требований?
- пользу от дополнительных ограничений языка: так проще рассуждать о программе.
- тестирование: когда и зачем.

Далее увидим, что системы типов предлагают возможность выражать как требования, так и рассуждения об их выполнении данной программой, ради чего и написан это текст.

## Что же такое тип?

### время существования

(статические) типы известны в compile-time
значения (переменных) известны в run-time
тип - та часть информации о значении, которая известна заранее.
(статический) тип - свойство самой программы.
значения переменных и результат на выходе - это свойства каждого отдельного запуска программы.

### дизайн

интерфейс выражается типами
его реализация выражается функциями

### Синтаксис: обозначения.

Мы хотим, чтобы тип имели не только переменные, но и функции.
Мы можем записывать функции вместе с их типом так: `fun (arg : Arg) : Res` например `length (str : String) : Int`.
Иногда мы хотим, чтобы аргументов было несколько `fun (a1 : A1,... ak : Ak) -> Res`.
Если захочется, то мы можем договориться обозначать отдельное значение в виде функции от нулевого числа переменных: `value : Res`.

Мы можем считать совокупность типов и функций заданного языка его *системой типов*. У каждого языка своя система типов.
Для рассуждений о системах типов в области computer science используются специальные теории: теория типов и теория категорий. Теория типов выросла из так называемого лямбда исчисления, следует классической логической парадигме (стройные ряды правил вывода), и ориентирована прежде всего на синтаксис (хотя не только). Теория категорий возникла в чистой математике, следует алгебраической парадигме (всё через операции), используется чаще для исследования семантики (хотя не только).

С точки зрения *теории типов* функции называются *выражениями со свободными переменными* и обозначаются более хитро: `a : Arg |- fun a : Res`, при этом аргументы функции и их тип здесь называют *контекстом*. Рассуждения о выражениях обычно ведутся в терминах подстановок и редукций - т.е. замены переменной на выражение, и преобразований одного выражения в эквивалентное ему другое.

С точки зрения *теории категорий* функции называются *морфизмами*, обозначаются `fun : Arg -> Res`. С морфизмами производятся композиции `f o g : A -> B -> C` и проверки на равенства. В теории категорий часто используют диаграммные обозначения, при этом тип выглядит как граница. [pictures]

### Семантика

Выражения языка нужны потому, что они что-то обозначают.
Синтаксис транслируется в другой язык.

Если нам нужно уметь выполнять программу, то это вычисительная реализация языка, интерпретатор или компилятор, которая так или иначе транслирует высокоуровневый язык в низкоуровневый, который уже умеет непосредственно выполняться, например, в язык команд процессора.

Если нам нужно уметь рассуждать о программе, то это формальная семантика, которая обычно сводится к трансляции исходного языка в более высокоуровневый язык, допускающий возможность выражения утверждений и доказательств. Иногда проще ввести систему рассуждений в рамках исходного языка.

Есть разные способы определения того, что считать значением программы, пригодным для рассуждения. Одно из них - операционная семантика - описывает все промежуточные состояния вычисляющего устройства. Противоположный подход - денотацинная семантика - когда всю программу мы представлем функцией из входа в выход. Типы входа и выхода - это интерфейс, сама функция - реализация, утверждения - равенства функций. Третий подход - аксиоматический - берет в основу сами требования и ведет рассуждения в терминах выполнения предусловий, постусловий и инвариантов.

### Вычисления уровня типов

Сколько всего типов в данной системе? Откуда берутся типы? Для рассуждений о типах удобно считать, что новые типы можно строить в результате применения фиксированного набора операций к исходному набору типов. Такой подход называется алгебраическими типами данных. Простые операции можно комбинировать в сложные, и рассматривать произвольные преобразования как "тип, зависящий от типа" или "тип с параметром", которые в программировании стали называть generics. Стандартный пример - тип списка `List[A]`, другие контейнеры. Самыми простыми оказываются, однако, сами операции - сумма типов, произведение, тип функций [подробнее]. Более сложными - типы, заданные рекурсивно - индуктивные и коиндуктивные.

В теории типов такие "типы с параметром" относят к явлению параметрического полиморфизма, рассуждения о них ведутся аналогично рассуждениям о функциях, только функциях другого уровня - уровня типов. Таким образом, `List` это функция уровня типов.

Типы, возникающие в ООП, на первый взгляд выглядят иначе, но на самом деле сводятся к описанным выше операциям и являются просто удобным синтаксисом. Более удобным для рассуждения, однако, оказывается понятие *класса типов* [подробнее].

Большинство императивных языков имеют ООП-систему типов ("классы"). Большинство функциональных языков имеют систему типов, порожденную лямбда-исчислением ("__λ__").

### итого

- функция - область, тип - граница
- функция - реализация, тип - интерфейс
- type - in compile-time, value - in run-time
- разные системы типов отличаются операциями порождения новых типов

## Требования, спецификация, верификация, тестирование.

ТЗ - к проекту
требования - к продукту
спецификация - формальные утверждения
верификация - формальное доказательство
[include]



----
